<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>Syllabus Template Slides</title>
    <link rel="shortcut icon" href="./favicon.ico" />
    <link rel="stylesheet" href="./dist/reset.css" />
    <link rel="stylesheet" href="./dist/reveal.css" />
    <link rel="stylesheet" href="./dist/theme/black.css" id="theme" />
    <link rel="stylesheet" href="./css/highlight/base16/zenburn.css" />

    <link rel="stylesheet" href="./assets/Reveal/makeschool.css" />

    <script>
      document.write(
        '<script src="http://' +
          (location.host || 'localhost').split(':')[0] +
          ':35729/livereload.js?snipver=1"></' +
          'script>'
      );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section data-markdown data-separator="^\n<!-- > -->\n" data-separator-vertical="^\n<!-- v -->\n">
          <textarea data-template>
            # ACS 4390 - Advanced queries 


More ideas: 

- Variables 
- Fragments
- Directives 

## GraphQL Query Language

The GraphQL query language has wide variety of features. Let's review them. 

**Types**

Types are the things you can query. Some types are query or mutation types. These are the types that define the root of a query. Things like: getPost, pserson, or allFilms. Others define resource types. These are things like: name, id, species, and title. 

Here: name and eyecolor are fields

```python
{
  person(personID:5) {
    name
    eyeColor
  }
}
```

**Arguments**

Are arguments are the value you supply to a query type. Arguments are the values you pass to a function. In a graphQL query they are the values we supply to Query and Mutation types. 

Here: name and species are arguments. Note! that an argument always has a type. In this case both arguments are strings. 

```python
{
  pet(name:"Frango", species:"Cat") {
    ...
  }
}
```

**Alias**

Since the response from a query also defines the shape of JSON response. You can run into a problem when you use the same query type. 

For example the following produces a problem in the response: 

```python
{
  person(personID: 1) {
    name
  }

  person(personID: 2) {
    name
  }
}
```

```json
{
  "data": {
    "person": {
      "name": "Luke"
    }, 
    "person": { 
      "name": "C3PO"
    }
  }
}
```

Here the two fields with the name "person" clash!

To fix this use an alias. The alias appears before the query type. 

```python
{
  personA: person(personID: 1) {
    name
  }

  personB: person(personID: 2) {
    name
  }
}
```

```json
{
  "data": {
    "personA": {
      "name": "Luke"
    }, 
    "personB": { 
      "name": "C3PO"
    }
  }
}
```

The alias is used fro the name of the field in the JSON response. 

**Fragments**

A fragment provides a reusable unit to use in queries where you may repeat code. 

Imagine you have to compare two characters and they have a many fields to compare: 

```python
{
  personA: person(personID: 1) {
    name
    eyeColor
    species {
      name
      language
    }
    homeworld {
      name
      diameter
    }
  }

  personB: person(personID: 2) {
    ...
  }
}
```

You can see this would create a long query with much duplciate code. 

A fragment will cleant his up. A fragment is defined with a name and a type.

```python
fragment description on Person {
  name
  eyeColor
  species {
    name
    language
  }
  homeworld {
    name
    diameter
  }
}
```

Here the name is `description` and the type is `Person`. All of the fields below would have to be valid for the `Person` type. 

Use a fragment by prefixing its name with `...`:

```python
{
  personA: person(personID: 1) {
    ...description
  }

  personB: person(personID: 2) {
    ...description
  }
}
```

**Operation Name**

Any query can be assigned an operation name. This is a name for the query. 

Here the name of the query is `CompareTwoPeople`:

```python
query CompareTwoPeople {
  personA: person(personID: 1) {
    ...description
  }

  personB: person(personID: 2) {
    ...description
  }
}
```

Use an operation name to make your queries less ambiguous and your code easier to understand. 

**Operation Type**

GraphQL supports three operation types: 

`query`, `mutation` and `subscription`

**Vartiables**






## Variables





Using variables with GraphQL

A query will often provide values to define and refine the expected results. GraphQL queries can define variables that may appear anywhere inside of a Query. This saves you the trouble of concatenating a long query string, and makes it easy to track variables used in a query by keeping them in one location. 

The following query looks for the first 15 market place listings via the GitHub API.

```GraphQL
query {
  marketplaceListings(first:15) {
    edges {
      node {
        id
        name
        shortDescription
      }
    }
  }
}
```

An obvious extension is to set a variable for the number of listings. 

```GraphQL
query MarketplaceListings($first: Int!) {
  marketplaceListings(first:$first) {
    edges {
      node {
        id
        name
        shortDescription
      }
    }
  }
}
```

Here a variable is defined like this: 

`MarketplaceListings($first: Int!)`

<!-- > -->

## After Class 

Finish the React + Apollo tutorial: <https://www.howtographql.com/react-apollo/0-introduction/>

- Complete the following chapters by next class: `Realtime Updates with GraphQL Subscriptions`, `Pagination`, `Summary`

<!-- > -->

### Tutorial Stretch Challenges

1. Implement the component that renders comments of authenticated users on links.
1. Finish off the Logout functionality
1. Implement a functionality that enables users to vote on comments of the links (one vote per link and user)
          </textarea>
        </section>
      </div>
    </div>

    <script src="./dist/reveal.js"></script>

    <script src="./mermaid/dist/mermaid.min.js"></script>

    <script src="./plugin/markdown/markdown.js"></script>
    <script src="./plugin/highlight/highlight.js"></script>
    <script src="./plugin/zoom/zoom.js"></script>
    <script src="./plugin/notes/notes.js"></script>
    <script src="./plugin/math/math.js"></script>
    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        slideNumber: true,
        highlight: {
          highlightOnLoad: false
        },
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath
        ]
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {"controls":true,"progress":true,"autoPlayMedia":false,"slideNumber":"c/t","showSlideNumber":"all","controlsTutorial":true,"controlsLayout":"edges","transition":"slide","transitionSpeed":"medium","minScale":0.5,"maxScale":3,"_":["Lessons/"],"static":"Slides"}, queryOptions);
    </script>


    <script>
      Reveal.initialize(options);
      Reveal.addEventListener('ready', function (event) {
        const blocks = Reveal.getRevealElement().querySelectorAll('pre code:not(.mermaid)');
        const hlp = Reveal.getPlugin('highlight');
        blocks.forEach(hlp.highlightBlock);
      });
    </script>

    <script>
      const mermaidOptions = extend({ startOnLoad: false }, {});
      mermaid.startOnLoad = false;
      mermaid.initialize(mermaidOptions);
      const cb = function (event) {
        mermaid.init(mermaidOptions, '.stack.present > .present pre code.mermaid');
        mermaid.init(mermaidOptions, '.slides > .present:not(.stack) pre code.mermaid');
      }
      Reveal.addEventListener('ready', cb);
      Reveal.addEventListener('slidetransitionend', cb);
    </script>
  </body>
</html>
